-- Add HubSpot-style view management system
-- This migration creates tables for the Display Layer (views) and Access Control Layer (permissions)
-- Note: This migration requires the profiles and custom_columns tables to exist
-- (created by the base schema migration 20250101010102_schema.sql)

-- ============================================================================
-- VIEWS TABLE (Display Layer - Core)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."views" (
    "id" bigint NOT NULL,
    "name" text NOT NULL,
    "description" text,
    "filter_config" jsonb,
    "is_default" boolean DEFAULT false NOT NULL,
    "is_shared" boolean DEFAULT false NOT NULL,
    "created_by" uuid,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT "views_pkey" PRIMARY KEY ("id")
);

-- Add foreign key constraint after table creation
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_schema = 'public' 
        AND constraint_name = 'views_created_by_fkey'
    ) THEN
        ALTER TABLE "public"."views" 
        ADD CONSTRAINT "views_created_by_fkey" 
        FOREIGN KEY ("created_by") 
        REFERENCES "public"."profiles"("id") 
        ON UPDATE CASCADE ON DELETE SET NULL;
    END IF;
END $$;

ALTER TABLE "public"."views" OWNER TO "postgres";

COMMENT ON TABLE "public"."views" IS 'View configurations combining column visibility and filters. Supports personal, shared, and default views.';
COMMENT ON COLUMN "public"."views"."filter_config" IS 'FilterGroup JSON structure matching saved_filters.filter_config format';
COMMENT ON COLUMN "public"."views"."is_default" IS 'Admin-configured default views available to all users';
COMMENT ON COLUMN "public"."views"."is_shared" IS 'Shared views available to team members (set by admins)';

ALTER TABLE "public"."views" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."views_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- Indexes for views
CREATE INDEX "views_created_by_idx" ON "public"."views" USING btree ("created_by");
CREATE INDEX "views_is_default_idx" ON "public"."views" USING btree ("is_default");
CREATE INDEX "views_is_shared_idx" ON "public"."views" USING btree ("is_shared");

-- Trigger for updated_at
CREATE OR REPLACE TRIGGER "update_views_updated_at" 
BEFORE UPDATE ON "public"."views" 
FOR EACH ROW 
EXECUTE FUNCTION "public"."update_updated_at_column"();

-- ============================================================================
-- VIEW_COLUMN_VISIBILITY TABLE (Display Layer - Column Overrides)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."view_column_visibility" (
    "id" bigint NOT NULL,
    "view_id" bigint NOT NULL,
    "column_name" text,
    "custom_column_id" bigint,
    "visible" boolean DEFAULT true NOT NULL,
    "display_order" integer NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT "view_column_visibility_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "view_column_visibility_view_id_fkey" FOREIGN KEY ("view_id") 
        REFERENCES "public"."views"("id") ON DELETE CASCADE,
    CONSTRAINT "view_column_visibility_custom_column_id_fkey" FOREIGN KEY ("custom_column_id") 
        REFERENCES "public"."custom_columns"("id") ON DELETE CASCADE,
    CONSTRAINT "view_column_visibility_column_type_check" CHECK (
        ("column_name" IS NOT NULL AND "custom_column_id" IS NULL) OR
        ("column_name" IS NULL AND "custom_column_id" IS NOT NULL)
    ),
    CONSTRAINT "view_column_visibility_view_column_unique" UNIQUE ("view_id", "column_name", "custom_column_id")
);

ALTER TABLE "public"."view_column_visibility" OWNER TO "postgres";

COMMENT ON TABLE "public"."view_column_visibility" IS 'Junction table linking views to column visibility overrides. Supports both default columns (via column_name) and custom columns (via custom_column_id) using a polymorphic pattern.';
COMMENT ON COLUMN "public"."view_column_visibility"."column_name" IS 'References column_visibility.column_name for default columns. Must be NULL if custom_column_id is set.';
COMMENT ON COLUMN "public"."view_column_visibility"."custom_column_id" IS 'References custom_columns.id for custom columns. Must be NULL if column_name is set.';

ALTER TABLE "public"."view_column_visibility" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."view_column_visibility_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- Indexes for view_column_visibility
CREATE INDEX "view_column_visibility_view_id_idx" ON "public"."view_column_visibility" USING btree ("view_id");
CREATE INDEX "view_column_visibility_column_name_idx" ON "public"."view_column_visibility" USING btree ("column_name");
CREATE INDEX "view_column_visibility_custom_column_id_idx" ON "public"."view_column_visibility" USING btree ("custom_column_id");
CREATE INDEX "view_column_visibility_display_order_idx" ON "public"."view_column_visibility" USING btree ("view_id", "display_order");

-- Trigger for updated_at
CREATE OR REPLACE TRIGGER "update_view_column_visibility_updated_at" 
BEFORE UPDATE ON "public"."view_column_visibility" 
FOR EACH ROW 
EXECUTE FUNCTION "public"."update_updated_at_column"();

-- ============================================================================
-- DATA_ACCESS_FIELD_PERMISSIONS TABLE (Access Control Layer - Field Level)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."data_access_field_permissions" (
    "id" bigint NOT NULL,
    "role" text NOT NULL,
    "column_name" text,
    "custom_column_id" bigint,
    "can_view" boolean DEFAULT true NOT NULL,
    "can_filter" boolean DEFAULT false NOT NULL,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT "data_access_field_permissions_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "data_access_field_permissions_custom_column_id_fkey" FOREIGN KEY ("custom_column_id") 
        REFERENCES "public"."custom_columns"("id") ON DELETE CASCADE,
    CONSTRAINT "data_access_field_permissions_column_type_check" CHECK (
        ("column_name" IS NOT NULL AND "custom_column_id" IS NULL) OR
        ("column_name" IS NULL AND "custom_column_id" IS NOT NULL)
    ),
    CONSTRAINT "data_access_field_permissions_role_column_unique" UNIQUE ("role", "column_name", "custom_column_id")
);

ALTER TABLE "public"."data_access_field_permissions" OWNER TO "postgres";

COMMENT ON TABLE "public"."data_access_field_permissions" IS 'Role-based field-level access control. Determines which fields each role can view and use in filters. Supports both default and custom columns.';
COMMENT ON COLUMN "public"."data_access_field_permissions"."role" IS 'RoleType enum value: super_admin, admin, member, locked, developer';
COMMENT ON COLUMN "public"."data_access_field_permissions"."can_view" IS 'Can this role see this field in tables and expanded views?';
COMMENT ON COLUMN "public"."data_access_field_permissions"."can_filter" IS 'Can this role use this field in filter configurations?';

ALTER TABLE "public"."data_access_field_permissions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."data_access_field_permissions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- Indexes for data_access_field_permissions
CREATE INDEX "data_access_field_permissions_role_idx" ON "public"."data_access_field_permissions" USING btree ("role");
CREATE INDEX "data_access_field_permissions_column_name_idx" ON "public"."data_access_field_permissions" USING btree ("column_name");
CREATE INDEX "data_access_field_permissions_custom_column_id_idx" ON "public"."data_access_field_permissions" USING btree ("custom_column_id");

-- Trigger for updated_at
CREATE OR REPLACE TRIGGER "update_data_access_field_permissions_updated_at" 
BEFORE UPDATE ON "public"."data_access_field_permissions" 
FOR EACH ROW 
EXECUTE FUNCTION "public"."update_updated_at_column"();

-- ============================================================================
-- DATA_ACCESS_RECORD_PERMISSIONS TABLE (Access Control Layer - Record Level)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."data_access_record_permissions" (
    "id" bigint NOT NULL,
    "role" text NOT NULL,
    "permission_type" text NOT NULL,
    "permission_scope" text,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT "data_access_record_permissions_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "data_access_record_permissions_permission_type_check" CHECK (
        "permission_type" IN ('riding', 'region', 'campus_club', 'all')
    ),
    CONSTRAINT "data_access_record_permissions_role_scope_unique" UNIQUE ("role", "permission_type", "permission_scope")
);

ALTER TABLE "public"."data_access_record_permissions" OWNER TO "postgres";

COMMENT ON TABLE "public"."data_access_record_permissions" IS 'Role-based record-level access control. Works alongside user-specific profile_*_access tables (user-specific overrides role-based).';
COMMENT ON COLUMN "public"."data_access_record_permissions"."role" IS 'RoleType enum value: super_admin, admin, member, locked, developer';
COMMENT ON COLUMN "public"."data_access_record_permissions"."permission_type" IS 'Type of access: riding, region, campus_club, or all';
COMMENT ON COLUMN "public"."data_access_record_permissions"."permission_scope" IS 'Specific riding/region/club name, or NULL for all access';

ALTER TABLE "public"."data_access_record_permissions" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."data_access_record_permissions_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- Indexes for data_access_record_permissions
CREATE INDEX "data_access_record_permissions_role_idx" ON "public"."data_access_record_permissions" USING btree ("role");
CREATE INDEX "data_access_record_permissions_type_scope_idx" ON "public"."data_access_record_permissions" USING btree ("permission_type", "permission_scope");

-- Trigger for updated_at
CREATE OR REPLACE TRIGGER "update_data_access_record_permissions_updated_at" 
BEFORE UPDATE ON "public"."data_access_record_permissions" 
FOR EACH ROW 
EXECUTE FUNCTION "public"."update_updated_at_column"();

-- ============================================================================
-- USER_VIEW_PREFERENCES TABLE (User State)
-- ============================================================================

CREATE TABLE IF NOT EXISTS "public"."user_view_preferences" (
    "id" bigint NOT NULL,
    "user_id" uuid NOT NULL,
    "current_view_id" bigint,
    "created_at" timestamp with time zone DEFAULT now() NOT NULL,
    "updated_at" timestamp with time zone DEFAULT now() NOT NULL,
    CONSTRAINT "user_view_preferences_pkey" PRIMARY KEY ("id"),
    CONSTRAINT "user_view_preferences_user_id_unique" UNIQUE ("user_id")
);

-- Add foreign key constraints after table creation
DO $$
BEGIN
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_schema = 'public' 
        AND constraint_name = 'user_view_preferences_user_id_fkey'
    ) THEN
        ALTER TABLE "public"."user_view_preferences" 
        ADD CONSTRAINT "user_view_preferences_user_id_fkey" 
        FOREIGN KEY ("user_id") 
        REFERENCES "public"."profiles"("id") 
        ON DELETE CASCADE;
    END IF;
    
    IF NOT EXISTS (
        SELECT 1 FROM information_schema.table_constraints 
        WHERE constraint_schema = 'public' 
        AND constraint_name = 'user_view_preferences_current_view_id_fkey'
    ) THEN
        ALTER TABLE "public"."user_view_preferences" 
        ADD CONSTRAINT "user_view_preferences_current_view_id_fkey" 
        FOREIGN KEY ("current_view_id") 
        REFERENCES "public"."views"("id") 
        ON DELETE SET NULL;
    END IF;
END $$;

ALTER TABLE "public"."user_view_preferences" OWNER TO "postgres";

COMMENT ON TABLE "public"."user_view_preferences" IS 'Stores user state: which view the user is currently using. One row per user.';
COMMENT ON COLUMN "public"."user_view_preferences"."current_view_id" IS 'The view ID currently selected by the user. NULL means using global defaults.';

ALTER TABLE "public"."user_view_preferences" ALTER COLUMN "id" ADD GENERATED BY DEFAULT AS IDENTITY (
    SEQUENCE NAME "public"."user_view_preferences_id_seq"
    START WITH 1
    INCREMENT BY 1
    NO MINVALUE
    NO MAXVALUE
    CACHE 1
);

-- Indexes for user_view_preferences
CREATE INDEX "user_view_preferences_user_id_idx" ON "public"."user_view_preferences" USING btree ("user_id");
CREATE INDEX "user_view_preferences_current_view_id_idx" ON "public"."user_view_preferences" USING btree ("current_view_id");

-- Trigger for updated_at
CREATE OR REPLACE TRIGGER "update_user_view_preferences_updated_at" 
BEFORE UPDATE ON "public"."user_view_preferences" 
FOR EACH ROW 
EXECUTE FUNCTION "public"."update_updated_at_column"();

-- ============================================================================
-- ROW LEVEL SECURITY POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE "public"."views" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."view_column_visibility" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."data_access_field_permissions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."data_access_record_permissions" ENABLE ROW LEVEL SECURITY;
ALTER TABLE "public"."user_view_preferences" ENABLE ROW LEVEL SECURITY;

-- Views: Admins can CRUD, authenticated users can read shared/default/personal views
CREATE POLICY "allow admin manage views" ON "public"."views" TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
);

CREATE POLICY "allow authenticated read views" ON "public"."views" FOR SELECT TO "authenticated"
USING (
    "is_default" = true 
    OR "is_shared" = true 
    OR "created_by" = auth.uid()
);

-- View column visibility: Same access as views
CREATE POLICY "allow admin manage view_column_visibility" ON "public"."view_column_visibility" TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."profiles" p
        WHERE p."id" = auth.uid()
        AND p."role" IN ('super_admin', 'admin')
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM "public"."profiles" p
        WHERE p."id" = auth.uid()
        AND p."role" IN ('super_admin', 'admin')
    )
);

CREATE POLICY "allow authenticated read view_column_visibility" ON "public"."view_column_visibility" FOR SELECT TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."views" v
        WHERE v."id" = "view_column_visibility"."view_id"
        AND (
            v."is_default" = true 
            OR v."is_shared" = true 
            OR v."created_by" = auth.uid()
        )
    )
);

-- Data access field permissions: Admins can CRUD, authenticated users can read
CREATE POLICY "allow admin manage field_permissions" ON "public"."data_access_field_permissions" TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
);

CREATE POLICY "allow authenticated read field_permissions" ON "public"."data_access_field_permissions" FOR SELECT TO "authenticated"
USING (true);

-- Data access record permissions: Admins can CRUD, authenticated users can read
CREATE POLICY "allow admin manage record_permissions" ON "public"."data_access_record_permissions" TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
)
WITH CHECK (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
);

CREATE POLICY "allow authenticated read record_permissions" ON "public"."data_access_record_permissions" FOR SELECT TO "authenticated"
USING (true);

-- User view preferences: Users can read/update their own, admins can read all
CREATE POLICY "allow users manage own preferences" ON "public"."user_view_preferences" TO "authenticated"
USING ("user_id" = auth.uid())
WITH CHECK ("user_id" = auth.uid());

CREATE POLICY "allow admin read preferences" ON "public"."user_view_preferences" FOR SELECT TO "authenticated"
USING (
    EXISTS (
        SELECT 1
        FROM "public"."profiles"
        WHERE "profiles"."id" = auth.uid()
        AND "profiles"."role" IN ('super_admin', 'admin')
    )
);

-- ============================================================================
-- GRANTS
-- ============================================================================

GRANT ALL ON TABLE "public"."views" TO "anon";
GRANT ALL ON TABLE "public"."views" TO "authenticated";
GRANT ALL ON TABLE "public"."views" TO "service_role";

GRANT ALL ON SEQUENCE "public"."views_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."views_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."views_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."view_column_visibility" TO "anon";
GRANT ALL ON TABLE "public"."view_column_visibility" TO "authenticated";
GRANT ALL ON TABLE "public"."view_column_visibility" TO "service_role";

GRANT ALL ON SEQUENCE "public"."view_column_visibility_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."view_column_visibility_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."view_column_visibility_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."data_access_field_permissions" TO "anon";
GRANT ALL ON TABLE "public"."data_access_field_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."data_access_field_permissions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."data_access_field_permissions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."data_access_field_permissions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."data_access_field_permissions_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."data_access_record_permissions" TO "anon";
GRANT ALL ON TABLE "public"."data_access_record_permissions" TO "authenticated";
GRANT ALL ON TABLE "public"."data_access_record_permissions" TO "service_role";

GRANT ALL ON SEQUENCE "public"."data_access_record_permissions_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."data_access_record_permissions_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."data_access_record_permissions_id_seq" TO "service_role";

GRANT ALL ON TABLE "public"."user_view_preferences" TO "anon";
GRANT ALL ON TABLE "public"."user_view_preferences" TO "authenticated";
GRANT ALL ON TABLE "public"."user_view_preferences" TO "service_role";

GRANT ALL ON SEQUENCE "public"."user_view_preferences_id_seq" TO "anon";
GRANT ALL ON SEQUENCE "public"."user_view_preferences_id_seq" TO "authenticated";
GRANT ALL ON SEQUENCE "public"."user_view_preferences_id_seq" TO "service_role";
